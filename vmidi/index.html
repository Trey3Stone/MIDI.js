<html>
<body scroll="no" style="margin: 0; overflow: hidden;">
<textarea id="inputNotes">
e4,e4,_,e4,_,c4,e4,_,
g4,_,_,_,g3,_,_,_,
c4,_,_,g3,_,_,e3,_,
_,a3,_,b3,_,a#3,a3,_,
g3,e4,g4,a4,_,f4,g4,
_,e4,_,c4,d4,b3,_,_
</textarea>

<button id="playButton" onClick="playback()">
	Play
</button>

<input type="file" id="fileUpload" accept=".mid" onChange="checkFile()">

<div id='d1' style="position: absolute; bottom: 0px">
	<canvas id="canvas" style="bottom:0px">
	  <p>Canvas not supported!</p>
	</canvas>
</div>

<script type="text/javascript">
	// DoReMi: c3,d3,e3,f3,g3,a3,b3,c4
//

	const A0_FREQ = 27.5;
	const KEYS = 8;

	const VOLUME = 0.3;

	const TEMPO = 45; // Supports 8th notes
	const METER = 60 / TEMPO / 8;
	BPM = 120;

	const NOTE_STEP = Math.pow(2, 1/12);

	const NOTE_TABLE = {
		'c' :  0,
		'c#':  1,
		'd' :  2,
		'd#':  3,
		'e' :  4,
		'f' :  5,
		'f#':  6,
		'g' :  7,
		'g#':  8,
		'a' :  9,
		'a#': 10,
		'b' : 11
	}

	const NOTES = [
		'c' ,
		'c#',
		'd' ,
		'd#',
		'e' ,
		'f' ,
		'f#',
		'g' ,
		'g#',
		'a' ,
		'a#',
		'b'
	]

	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerWidth / 6;

	drawCanvas();

	//noteToFreq("c#4");
/*
	let audioCon = new AudioContext();
	let oscillator = audioCon.createOscillator();

	oscillator.frequency.value = 440;
	oscillator.connect(audioCon.destination);
	oscillator.start();
	oscillator.stop(audioCon.currentTime + 3);


	inputNotes = document.getElementById("inputNotes").value;



	alert(oscillator.frequency.value);
	//alert(2);
*/

function drawCanvas() {
	

	ctx.fillStyle = "rgb(40, 40, 40)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	ctx.strokeStyle = "rgb(40, 40, 40)";

	const keyWidth = canvas.width/52;
	const keyHeight = 6*keyWidth;

	var xFill = 0;
	ctx.fillStyle = "rgb(250, 250, 250)";
	
	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] == '#') {
			continue;
		}


		
		ctx.fillRect(xFill+1, canvas.height - keyHeight, keyWidth-2, keyHeight-2);
		xFill = xFill + keyWidth;
	}

	xFill = 0;
	ctx.fillStyle = "rgb(250, 150, 100)";

	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] != '#') {
			xFill = xFill + keyWidth;
			continue;
		}


		
		ctx.fillRect(xFill - keyWidth/4, canvas.height - keyHeight, keyWidth/2, keyHeight*0.6-2);
		
	}

}


function checkFile() {
	//document.write(note+"<br>");
	
	var inputFile = document.getElementById("fileUpload").files[0];

	if (inputFile == undefined) {
		alert("No valid file selected");
		return;
	}

	var reader = new FileReader();
	reader.onload = function(e) {
		decodeFile(e.target.result);
	}

	reader.readAsArrayBuffer(inputFile);

}

function decodeFile(res) {

	var data = new DataView(res);
	
	var chunkId = String.fromCharCode.apply(String, [data.getUint8(0), data.getUint8(1), data.getUint8(2), data.getUint8(3)]);
	var chunkLen = data.getUint32(4);
 	
 	var format = data.getUint16(8);
 	var ntracks = data.getUint16(10);
 	var tickdiv = data.getUint16(12);

	console.log("ntracks: " +ntracks);

 	if (tickdiv & 0x8000 != 0) {
 		alert("Timecodes not implemented yet");
 		return;
 	}

 	if (format != 1) {
 		alert("Format not implemented yet");
 		return;
 	}

 	var ppqn = tickdiv & 0x7fff;

	console.log("speeedd"+tickdiv);

	chunkLen = data.getUint32(18);

	var start = 22+chunkLen;

	
	chunkId = String.fromCharCode.apply(String,
		[data.getUint8(start), data.getUint8(start+1), data.getUint8(start+2), data.getUint8(start+3)]);

	chunkLen = data.getUint32(start+4);

	console.log(chunkId +": " +chunkLen);

	var events = [];

	var dt = 0;

	var event = {};

	var i = start + 8;

	for (j = 0; j < 20; j++) {
		//console.log((i+j) + ": " + data.getUint8(i+j));
	}

	var lastStatus = 0;

	while(i < (start + 8 + chunkLen)) {
		
		var next = data.getUint8(i++);

		//console.log((i-1)+" " +(next));

		dt = (dt << 7) | (next & 0x7f);
		if ((next & 0x80) == 0) {
			//console.log("go0");
			event = {"time" : dt};
			dt = 0;

			event["status"] = data.getUint8(i++);
			if (event["status"] < 128) {
				event["status"] = lastStatus;
				i--;
			} else {
				lastStatus =event["status"];
			}
			switch(event["status"] >> 4) {
				case 0x8:
					event["note"] = data.getUint8(i++);
					event["velocity"] = data.getUint8(i++);
					break;
				case 0x9:
					//console.log(event["status"] & 0xf);
					event["note"] = data.getUint8(i++);
					event["velocity"] = data.getUint8(i++);
					break;
				case 0xA:
					i+=2;
					break;
				case 0xB:
					i+=2;
					break;
				case 0xC:
					i+=1;
					break;
				case 0xD:
					i+=1;
					break;
				case 0xE:
					i+=2;
					break;
				case 0xF:
					if ((event["status"] & 0xF) == 0xF) {
						var opt = data.getUint8(i++);
						if ((opt >> 4) < 0) {
							i+=data.getUint8(i);
						} else {
							if (opt == 0x2F) {
								i = Math.inf;
							}
						}
					} else {
						i+=data.getUint8(i);
					}
					break;
				default:
					
					i = Math.inf;
					//while(data.getUint8(i++) >> 7 == 0)
			}

			//console.log("go1");
			events.push(event);
			
		}
		
	}
	
	console.log(events.length);
	playMidi(events, ppqn);
}

function noteToFreq(note) {
	
	if (note[0] == '_') {
		return 0;
	}

	var key = note.slice(0, -1);
	var oct = note.slice(-1);

	//document.write(note+' '+key+' '+oct+'<br>');

	// TODO: assert key and oct are valid

	var freq = A0_FREQ * Math.pow(2, parseInt(oct) + (NOTE_TABLE[key] - 9)/12);
	return freq;
}

function midiToFreq(note) {
	//21-108
	console.log('note '+note);
	return A0_FREQ * Math.pow(2, (note-21)/12);
}

function compile() {
	var inputNotes = document.getElementById("inputNotes").value.trim().toLowerCase().replace(/\n/g, '').split(",");

	var notes = inputNotes.map(function(value) {return noteToFreq(value);});

	return notes;
}

function playMidi(events, ppqn) {
	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	
	//console.log(events.length);

	var timeStep = 60 / (BPM * ppqn);

	var waves = [];

	var wc = 0;

	function getWave(key) {
		//console.log('before'+waves.length);
		var wave = waves[key];
		//console.log('after '+waves.length);
		if (wave == undefined) {
			console.log("New wave " + (++wc));
			var osc = audioCtx.createOscillator();
			var vol = audioCtx.createGain();

			osc.type = "triangle";
			vol.gain.value = 0;

			osc.connect(vol);
			vol.connect(audioCtx.destination);
			osc.start();

			wave = {"osc" : osc, "vol" : vol};
			
			
			//wave.onended = function() {
				//waves.push(this);
			//}
			waves[key] = wave;
			
			//wave.start();
		} else {
			console.log("Old wave");
		}

		return wave;
	}

	var i = 0;

	function playMidi_r() {
		//console.log(++i + "events processed");
		var event = events.shift();

		if (event != undefined && event["status"] >> 4 == 0x9) {
			
			var wave = getWave(event["note"]);
			if (event["velocity"] == 0) {
				//wave.disconnect(audioCtx.destination);
				wave["vol"].gain.setTargetAtTime(0, audioCtx.currentTime, 0.015);
			} else {
				wave["osc"].frequency.value = midiToFreq(event["note"]);
				console.log(event["note"]+ " on");
				//wave.connect(audioCtx.destination);
				wave["vol"].gain.setTargetAtTime(VOLUME, audioCtx.currentTime, 0.015);
			}
			//console.log(wave.frequency.value);
			//wave.stop(audioCtx.currentTime + 0.5);
		} else if (event != undefined && event["status"] >> 4 == 0x8) {
			var wave = waves[event["note"]];
			//console.log(wave);
			//wave.frequency.value = midiToFreq(event["note"]);
			//console.log(wave.frequency.value);
			console.log(event["note"]+ " off");
			//wave.disconnect(audioCtx.destination);
			wave["vol"].gain.setTargetAtTime(0, audioCtx.currentTime, 0.015);
		}

		if (events.length > 0) {
			setTimeout(playMidi_r, timeStep*events[0]["time"]*1000);
		}
	}

	playMidi_r();
}


function playback() {
	var notes = compile()


	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	// we create the gain module, named as volume, and connect it to our
	var volume = audioCtx.createGain();
	volume.connect(audioCtx.destination);
	//these sines are the same, exept for the last connect statement.
	//Now they are connected to the volume gain module and not to the au
	var wave = audioCtx.createOscillator();
	wave.type = "triangle";
	wave.frequency.value = 440;
	//wave.detune.value = -100;
	//sinea.type = "sine";
	volume.gain.value = 0;
	wave.start();
	//wave.stop(audioCtx.currentTime + 3);
	wave.connect(volume);

	playRecursive(audioCtx, wave, volume, notes, 0);

}

function playRecursive(context, wave, volume, notes, i) {
	if (i >= notes.length) {
		wave.stop(context.currentTime + 0.1);
		return;
	}

	

	if (notes[i] != 0) {
		

		wave.frequency.value = notes[i];
		//volume.gain.value = 0.2;
		volume.gain.setTargetAtTime(VOLUME, context.currentTime, 0.01);

		volume.gain.setTargetAtTime(0, context.currentTime + 0.9*METER, 0.01);
	}

	setTimeout(playRecursive, 1000*METER, context, wave, volume, notes, i+1);
}



</script>

</body>
</html>