<html>
<body scroll="no" style="margin: 0; overflow: hidden;">
<textarea id="inputNotes">
e4,e4,_,e4,_,c4,e4,_,
g4,_,_,_,g3,_,_,_,
c4,_,_,g3,_,_,e3,_,
_,a3,_,b3,_,a#3,a3,_,
g3,e4,g4,a4,_,f4,g4,
_,e4,_,c4,d4,b3,_,_
</textarea>

<button id="playButton" onClick="playback()">
	Play
</button>

<input type="file" id="fileUpload" accept="audio/*" onChange="checkFile()">

<div id='d1' style="position: absolute; bottom: 0px">
	<canvas id="canvas" style="bottom:0px">
	  <p>Canvas not supported!</p>
	</canvas>
</div>

<script type="text/javascript">
	// DoReMi: c3,d3,e3,f3,g3,a3,b3,c4
//

	const A0_FREQ = 27.5;
	const KEYS = 8;

	const VOLUME = 0.3;

	const TEMPO = 45; // Supports 8th notes
	const METER = 60 / TEMPO / 8;

	const NOTE_STEP = Math.pow(2, 1/12);

	const NOTE_TABLE = {
		'c' :  0,
		'c#':  1,
		'd' :  2,
		'd#':  3,
		'e' :  4,
		'f' :  5,
		'f#':  6,
		'g' :  7,
		'g#':  8,
		'a' :  9,
		'a#': 10,
		'b' : 11
	}

	const NOTES = [
		'c' ,
		'c#',
		'd' ,
		'd#',
		'e' ,
		'f' ,
		'f#',
		'g' ,
		'g#',
		'a' ,
		'a#',
		'b'
	]

	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerWidth / 6;

	drawCanvas();

	//noteToFreq("c#4");
/*
	let audioCon = new AudioContext();
	let oscillator = audioCon.createOscillator();

	oscillator.frequency.value = 440;
	oscillator.connect(audioCon.destination);
	oscillator.start();
	oscillator.stop(audioCon.currentTime + 3);


	inputNotes = document.getElementById("inputNotes").value;



	alert(oscillator.frequency.value);
	//alert(2);
*/

function drawCanvas() {
	

	ctx.fillStyle = "rgb(40, 40, 40)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	ctx.strokeStyle = "rgb(40, 40, 40)";

	const keyWidth = canvas.width/52;
	const keyHeight = 6*keyWidth;

	var xFill = 0;
	ctx.fillStyle = "rgb(250, 250, 250)";
	
	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] == '#') {
			continue;
		}


		
		ctx.fillRect(xFill+1, canvas.height - keyHeight, keyWidth-2, keyHeight-2);
		xFill = xFill + keyWidth;
	}

	xFill = 0;
	ctx.fillStyle = "rgb(250, 150, 100)";

	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] != '#') {
			xFill = xFill + keyWidth;
			continue;
		}


		
		ctx.fillRect(xFill - keyWidth/4, canvas.height - keyHeight, keyWidth/2, keyHeight*0.6-2);
		
	}

}


function checkFile() {
	//document.write(note+"<br>");
	
	var inputFile = document.getElementById("fileUpload").files[0];

	if (inputFile == undefined) {
		alert("No valid file selected");
		return;
	}

	var audioCtx = new (window.AudioContext || window.webkitAudioContext);

	var reader = new FileReader();
	reader.onload = function(e) {
		audioCtx.decodeAudioData(e.target.result).then(function(buf) {
			decodeFile(buf);
		})
	}

	reader.readAsArrayBuffer(inputFile);

}

function decodeFile(buf) {
	alert("decoding");

	var offlineCtx = new OfflineAudioContext(1, buf.length, buf.sampleRate);



	var audioSource = offlineCtx.createBufferSource();
	audioSource.buffer = buf;
	
	var analyzer = offlineCtx.createAnalyser();
	analyser.fftSize = 2048;

	var noteArr = [];
	function decodeFile_r(ctx, analyser, notes) {
		var dataArray = new Float32Array(analyser.frequencyBinCount);
		analyser.getFloatFrequencyData(dataArray);

		




	}



			//audioSource.connect(audioCtx.destination);
			//audioSource.start(0);
}

function noteToFreq(note) {
	
	if (note[0] == '_') {
		return 0;
	}

	var key = note.slice(0, -1);
	var oct = note.slice(-1);

	//document.write(note+' '+key+' '+oct+'<br>');

	// TODO: assert key and oct are valid

	var freq = A0_FREQ * Math.pow(2, parseInt(oct) + (NOTE_TABLE[key] - 9)/12);
	return freq;
}

function compile() {
	var inputNotes = document.getElementById("inputNotes").value.trim().toLowerCase().replace(/\n/g, '').split(",");

	var notes = inputNotes.map(function(value) {return noteToFreq(value);});

	return notes;
/*
	for (var note in inputNotes) {
		var freq2 = 

		notes.push(freq2);
		

	}
*/
	

}


function playback() {
	var notes = compile()


	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	// we create the gain module, named as volume, and connect it to our
	var volume = audioCtx.createGain();
	volume.connect(audioCtx.destination);
	//these sines are the same, exept for the last connect statement.
	//Now they are connected to the volume gain module and not to the au
	var wave = audioCtx.createOscillator();
	wave.type = "triangle";
	wave.frequency.value = 440;
	//wave.detune.value = -100;
	//sinea.type = "sine";
	volume.gain.value = 0;
	wave.start();
	//wave.stop(audioCtx.currentTime + 3);
	wave.connect(volume);

	playRecursive(audioCtx, wave, volume, notes, 0);

}

function playRecursive(context, wave, volume, notes, i) {
	if (i >= notes.length) {
		wave.stop(context.currentTime + 0.1);
		return;
	}

	

	if (notes[i] != 0) {
		

		wave.frequency.value = notes[i];
		//volume.gain.value = 0.2;
		volume.gain.setTargetAtTime(VOLUME, context.currentTime, 0.01);

		volume.gain.setTargetAtTime(0, context.currentTime + 0.9*METER, 0.01);
	}

	setTimeout(playRecursive, 1000*METER, context, wave, volume, notes, i+1);
}



</script>

</body>
</html>