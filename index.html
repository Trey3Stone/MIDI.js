<html>
<body bgcolor="#202020" scroll="no" style="margin: 0; overflow: hidden;">
<textarea id="inputNotes">
e4,e4,_,e4,_,c4,e4,_,
g4,_,_,_,g3,_,_,_,
c4,_,_,g3,_,_,e3,_,
_,a3,_,b3,_,a#3,a3,_,
g3,e4,g4,a4,_,f4,g4,
_,e4,_,c4,d4,b3,_,_
</textarea>

<button id="playButton" onClick="playback()">
	Play
</button>



<div id='d1' style="position: absolute; bottom: 0px">
	<canvas id="canvas" style="bottom:0px">
	  <p>Canvas not supported!</p>
	</canvas>
	<input type="file" id="fileUpload" accept=".mid" onChange="checkFile()">
</div>

<script type="text/javascript">
	// DoReMi: c3,d3,e3,f3,g3,a3,b3,c4
//

	const A0_FREQ = 27.5;
	const KEYS = 8;

	const VOLUME = 0.15;

	const TEMPO = 45; // Supports 8th notes
	const METER = 60 / TEMPO / 8;

	const SIZE_SECONDS = 3;
	const PLAYBACK_DELAY = 2;

	

	const NOTE_STEP = Math.pow(2, 1/12);

	const NOTE_TABLE = {
		'c' :  0,
		'c#':  1,
		'd' :  2,
		'd#':  3,
		'e' :  4,
		'f' :  5,
		'f#':  6,
		'g' :  7,
		'g#':  8,
		'a' :  9,
		'a#': 10,
		'b' : 11
	}

	const NOTES = [
		'c' ,
		'c#',
		'd' ,
		'd#',
		'e' ,
		'f' ,
		'f#',
		'g' ,
		'g#',
		'a' ,
		'a#',
		'b'
	]

	const KEY_DRAW_OFFSETS = [
		0,
		1,
		1,
		2,
		2,
		3,
		4,
		4,
		5,
		5,
		6,
		6
	]

	//var BPM = 120;

	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;//Width / 6;

	drawCanvas();


function drawCanvas() {
	
	ctx.save();

	let width = canvas.width;
	let height = Math.ceil(width / 10);

	ctx.translate(0, canvas.height - height)

	ctx.beginPath();
	ctx.rect(0, 0, width, height);
	ctx.clip();

	ctx.strokeStyle = "rgb(16, 16, 16)";

	//ctx.fillStyle = "rgb(40, 40, 40)";
	//ctx.fillRect(0, 0, canvas.width, canvas.height);

	//ctx.strokeStyle = "rgb(40, 40, 40)";

	const keyWidth = width/52;
	const keyHeight = height;

	var xFill = 0;
	ctx.fillStyle = "rgb(255, 255, 255)";
	
	ctx.lineWidth = 2;

	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] == '#') {
			continue;
		}


		
		//ctx.fillRect(xFill+1, canvas.height - keyHeight, keyWidth-2, keyHeight-2);
		fillRoundedRect(xFill+1, 0, keyWidth-2, keyHeight-2, 2);
		xFill = xFill + keyWidth;
	}

	xFill = 0;
	ctx.fillStyle = "rgb(0, 0, 0)";

	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] != '#') {
			xFill = xFill + keyWidth;
			continue;
		}


		
		//ctx.fillRect(xFill - keyWidth/4, canvas.height - keyHeight, keyWidth/2, keyHeight*0.6-2);
		fillRoundedRect(xFill - keyWidth/4, 0, keyWidth/2, keyHeight*0.6-2, 2);
		
	}

	ctx.fillStyle = "rgb(255, 255, 255)";
	ctx.lineWidth = 12;
	fillRoundedRect(0, 0, width, 4, 2);

	ctx.restore();

}

function fillRoundedRect(x, y, w, h, r) {
	ctx.save();

	ctx.translate(x, y);

	ctx.beginPath();
	ctx.arc(r, r, r, Math.PI, 3*Math.PI/2);
	ctx.arc(w - r, r, r, 3*Math.PI/2, 0);
	ctx.arc(w - r, h - r, r, 0, Math.PI/2);
	ctx.arc(r, h - r, r, Math.PI/2, Math.PI);

	ctx.closePath();

	//ctx.strokeStyle = "rgb(40, 40, 40)";
	
	ctx.stroke();

	ctx.fill();

	ctx.restore();
}

function fillLightRect(x, y, w, h, r) {

	//w = Math.max(w, 2*r);
	h = Math.max(h, 2*r);

	ctx.save();

	ctx.translate(x, y);

	ctx.beginPath();
	ctx.arc(r, r, r, Math.PI, 3*Math.PI/2);
	ctx.arc(w - r, r, r, 3*Math.PI/2, 0);
	ctx.arc(w - r, h - r, r, 0, Math.PI/2);
	ctx.arc(r, h - r, r, Math.PI/2, Math.PI);

	ctx.closePath();

	//ctx.strokeStyle = "rgb(40, 40, 40)";
	
	ctx.shadowColor = ctx.strokeStyle;
	ctx.shadowBlur = 10;

	ctx.stroke();
	//ctx.stroke();
	//ctx.stroke();

	//ctx.fill();

	ctx.restore();
}

function fillKeyBurst(x, y, w, r) {
	const RES = 10;
	const ANG = Math.PI / 4;
	const STEP = 2 * ANG / RES;

	//const OFFSET = (w/2)/(Math.tan(ANG));

	ctx.save();

	


	//theta = (w/2)/(tan(ANG))

	//console.log(ctx.fillStyle + "00");

	ctx.translate(x + w/2, y);

	ctx.beginPath();
	ctx.moveTo(-w/2, 0);
	ctx.arc(0, w/2, r + w/2, -3*Math.PI/4, -Math.PI/4);
	ctx.lineTo(w/2, 0);
	ctx.closePath();
	ctx.clip();


	let grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
	grad.addColorStop(0, ctx.fillStyle);
	grad.addColorStop(0.25, ctx.fillStyle + "90");
	grad.addColorStop(0.5, ctx.fillStyle + "40");
	grad.addColorStop(0.75, ctx.fillStyle + "10");
	grad.addColorStop(0.875, ctx.fillStyle + "04");
	grad.addColorStop(1, ctx.fillStyle + "00");


	ctx.fillStyle = grad;

	//ctx.shadowColor = grad;
	//ctx.shadowBlur = 10;

	ctx.fillRect(-r, -r, 2*r, 2*r);

	//ctx.stroke();
	
	//ctx.fill();

	ctx.restore();
}

function drawNotes(audioCtx, notes) {
	
	const times = [];
	let fps;

	function refreshLoop() {
	  window.requestAnimationFrame(() => {
	    const now = performance.now();
	    while (times.length > 0 && times[0] <= now - 1000) {
	      times.shift();
	    }
	    times.push(now);
	    fps = times.length;
	    console.log(fps);
	    refreshLoop();
	  });
	}

	refreshLoop();
	

	var width = canvas.width;
	var height = canvas.height - Math.ceil(canvas.width/10);

	var keyWidth = width/52;

	function drawNotes_r(audioCtx, notes, curNotes, i) {
		//console.log("1: " + curNotes.length);
		var curTime = audioCtx.currentTime;

		ctx.save();




		

		ctx.beginPath();
		ctx.rect(0, 0, width, height);
		ctx.clip();

		ctx.clearRect(0, 0, width, height);

		ctx.lineWidth = 0;
		ctx.strokeStyle = "rgb(60, 60, 60)";


		ctx.beginPath();

		for (let i = 2; i < 52; i+=7) {
			
			ctx.moveTo(i * keyWidth, 0);
			ctx.lineTo(i * keyWidth, height);
			
		}


		for (let i = 0; i < Math.ceil(2*SIZE_SECONDS); i++) {
			let time = Math.ceil(2*curTime + i);
			let y = (time - 2*curTime) / SIZE_SECONDS * height / 2;
			ctx.moveTo(0, height - y);
			ctx.lineTo(width, height - y);
		}



		ctx.stroke();
		

		ctx.lineWidth = 4;

		//for (var note of notes) {
		while (i < notes.length) {
			var note = notes[i];
			if (note["start"] <= (curTime + SIZE_SECONDS)) {
				//console.log("added");
				//if (keyIsSharp(note["key"])) {
					curNotes.push(note);
				//} else {
				//	curNotes.unshift(note);
				//}
				
				i++;
			} else {
				break;
			}
		}
		//console.log("2: " + curNotes.length);

		curNotes = curNotes.filter(function(note) {
			return note["end"] > curTime;
		});

		//console.log("3: " + curNotes.length);

		//ctx.strokeStyle = "rgb(40, 40, 40)";

		let noteWidth = keyWidth;

		for (var note of curNotes) {




			//let testColor = "hsl(" + (720 * note["channel"] / 16) + ", 100%, 60%)";
			
			//console.log(note["channel"]);

			
			let noteHeight = (note["end"] - note["start"]) / SIZE_SECONDS * height;

			//var noteX = width * (note["key"] - 21) / 52;

			//console.log(noteX);
			let noteX = (2 + (Math.floor(note["key"] / 12) - 2) * 7  + KEY_DRAW_OFFSETS[note["key"] % 12]) * keyWidth;
			//(note["key"] - 21) * keyWidth;



			let noteY = height * (1 - (note["end"] - curTime) / SIZE_SECONDS);

			if (keyIsSharp(note["key"])) {
				//noteWidth /= 2;
				noteX -= noteWidth / 2;
				//noteWidth / 2;
			}

			//0	225	550	775
			//0	225	190	55


			


			//ctx.fillRect(noteX, noteY, 20, noteHeight);
			
			

			//ctx.lineWidth = 0;


			let hue = (4*curTime + 10*note["start"] + 720 * (163*(1+note["channel"])%16) / 16)

			if (note["start"] > curTime) {
				ctx.strokeStyle = "hsl(" + hue + ", 80%, 60%)";
				ctx.fillStyle = "hsl(" + hue + ", 80%, 60%)";
				//ctx.fillStyle = "rgb(200, 100, 100)";
				//fillKeyBurst(noteX, height, noteWidth, 40);
			} else {
				//let testColor = "hsl(" + (720 * (163*note["channel"]%16) / 16) + ", 80%, 60%)";
				//ctx.fillStyle = testColor;
				ctx.strokeStyle = "hsl(" + hue + ", 80%, 80%)";
				ctx.fillStyle = "hsl(" + hue + ", 80%, 80%)";

				fillKeyBurst(noteX, height, keyWidth, 40);
			}


			//fillRoundedRect(noteX, noteY, noteWidth, noteHeight, 5);
			
			fillLightRect(noteX + keyWidth / 2 - 5, noteY, 10, noteHeight, 5);
			//ctx.fillRect(noteX, noteY, noteWidth, noteHeight);
			
			//fillLightRect(noteX, noteY, noteWidth, noteHeight);

			
		}



		ctx.restore();

		if (curNotes.length > 0 || i < notes.length) {
			window.requestAnimationFrame(function(timestamp) {
				drawNotes_r(audioCtx, notes, curNotes, i);
			});
		} else {
			ctx.clearRect(0, 0, width, height);
		}
	}

	drawNotes_r(audioCtx, notes, [], 0);	
}

function keyIsSharp(key) {
	//key = key % 12;
	return (key & 1) == ((key % 12) < 5);
	//((key < 5) && (key & 1 == 1)) || 
}




function checkFile() {
	//document.write(note+"<br>");
	
	var inputFile = document.getElementById("fileUpload").files[0];

	if (inputFile == undefined) {
		alert("No valid file selected");
		return;
	}

	var reader = new FileReader();
	reader.onload = function(e) {
		decodeFile(e.target.result);
	}

	reader.readAsArrayBuffer(inputFile);

}

function decodeFile(res) {

	var data = new DataView(res);
	
	var chunkId = String.fromCharCode.apply(String, [data.getUint8(0), data.getUint8(1), data.getUint8(2), data.getUint8(3)]);
	var chunkLen = data.getUint32(4);
 	
 	var format = data.getUint16(8);
 	var ntracks = data.getUint16(10);
 	var tickdiv = data.getUint16(12);

	console.log("ntracks: " +ntracks);

 	if (tickdiv & 0x8000 != 0) {
 		alert("Timecodes not implemented yet");
 		return;
 	}

 	if (format != 1) {
 		alert("Format not implemented yet");
 		return;
 	}

 	var ppqn = tickdiv & 0x7fff;

	console.log("speeedd"+tickdiv);

	chunkLen = data.getUint32(18);

	console.log("Tempo Chunk size: "+chunkLen);

	//var start = 22+chunkLen;

	var start = 14;

//Marker, Cue Point, Tempo, SMPTE Offset, Time Signature, and Key Signature

/*
Metas: 84 0 81 9 47 82 54
       54 0 51 9 2f 52 36




*/


	/*
	chunkId = String.fromCharCode.apply(String,
		[data.getUint8(start), data.getUint8(start+1), data.getUint8(start+2), data.getUint8(start+3)]);

	chunkLen = data.getUint32(start+4);
*/
	//console.log(chunkId +": " +chunkLen);

	var i = start;

	function readChunk() {
		console.log("reading");

		chunkId = String.fromCharCode.apply(String,
			[data.getUint8(i), data.getUint8(i+1), data.getUint8(i+2), data.getUint8(i+3)]);

		if (chunkId != "MTrk") {
			alert(chunkId);
			return;
		}

		chunkLen = data.getUint32(i+4);

		start = i + 8;
		i = start;

		let events = [];
		let lastStatus = 0;

		let dt = 0;
		let time = 0;

		while(i < start + chunkLen - 1) {
			
			var next = data.getUint8(i++);

			//console.log((i-1)+" " +(next));

			dt = (dt << 7) | (next & 0x7f);
			if ((next & 0x80) == 0) {
				//console.log("go0");
				time += dt;
				dt = 0;
				event = {"time" : time};

				event["status"] = data.getUint8(i++);
				if (event["status"] < 128) {
					event["status"] = lastStatus;
					i--;
				} else {
					lastStatus = event["status"];
				}

				//console.log("EVENT: " + event["status"] + " " + (i - 1 - start) + " " + event["time"]);

				//var testPutInEventsList = false;

				switch(event["status"] >> 4) {
					case 0x8:
						event["channel"] = event["status"] & 0xF;
						event["key"] = data.getUint8(i++);
						//console.log(data.getUint8(i));
						event["velocity"] = data.getUint8(i++);
						//testPutInEventsList = true;
						break;
					case 0x9:
						event["channel"] = event["status"] & 0xF;
						event["key"] = data.getUint8(i++);
						event["velocity"] = data.getUint8(i++);
						//testPutInEventsList = true;
						break;
					case 0xA:
						i+=2;
						break;
					case 0xB:
						i+=2;
						break;
					case 0xC:
						i+=1;
						break;
					case 0xD:
						i+=1;
						break;
					case 0xE:
						i+=2;
						break;
					case 0xF:
						if (event["status"] == 0xFF) {
							let opt = data.getUint8(i++);
							event["status"] = 0xFF00 | opt;
							//console.log("New meta event: " + opt + " " + data.getUint8(i) + " " + (i - 1 - start));
							switch(opt) {
								case 0x51:
									i++;
									let tempo = data.getUint8(i++);
									tempo = (tempo << 8) | data.getUint8(i++);
									tempo = (tempo << 8) | data.getUint8(i++);
									//console.log("tempo: " + tempo);
									//console.log("bpm?: " + (60000000/(tempo)));
									BPM = 60000000/tempo;

									let timeStep = tempo / (1000000 * ppqn);

									event["step"] = timeStep;


									console.log("bpm: " + BPM);
									break;
								default:
									var length = data.getUint8(i++);
									i+=length;
							}


							
						} else {
							console.log(event["status"] + " " + data.getUint8(i));
						}
							/*if ((opt >> 4) == 0) {
								i+=data.getUint8(i);
							} else {
								if (opt == 0x2F) {
									//return events;
								}
							}
						} else {
							i+=data.getUint8(i);
						}*/
						//console.log(event["status"] + " " + data.getUint8(i));
						break;
					default:
						alert("Something broke.");
						console.log("ERROR");
						return;
						//while(data.getUint8(i++) >> 7 == 0)
				}

				//console.log("go1");
				//if (testPutInEventsList) {
				events.push(event);
				//}
				
				
			}
			
		}
		i = start + chunkLen;
		return events;
	}

	function mergeStreams(a, b) { // Add key as param?
		var i = 0;
		while (b.length > 0) {
			if (a[i] == undefined || b[0]["time"] < a[i]["time"]) {
				a.splice(i, 0, b.shift());
			}

			i++
		}

		return a;
	}


	//timing = compileMidi(readChunk(), ppqn);

	//stream = [];
	let stream = readChunk();

	//var testcount = stream.length;
	console.log("length: " + stream.length);
	for (let n = 1; n < ntracks; n++) {
		//console.log("track");
		//var test = compileMidi(timing, readChunk());
		//console.log("length: " + test.length);
		//testcount += test.length;
		//mergeStreams(stream, test);
		let track = readChunk();
		mergeStreams(stream, track);
	}

	//console.log(testcount + " " + stream.length);
	//var keys = compileMidi(streams[0], ppqn);

	const DEFAULT_BPM = 120;
	stream = compileMidi(stream, 60 / (DEFAULT_BPM*ppqn));

	playMidi(stream);
}

function noteToFreq(note) {
	
	if (note[0] == '_') {
		return 0;
	}

	var key = note.slice(0, -1);
	var oct = note.slice(-1);

	//document.write(note+' '+key+' '+oct+'<br>');

	// TODO: assert key and oct are valid

	var freq = A0_FREQ * Math.pow(2, parseInt(oct) + (NOTE_TABLE[key] - 9)/12);
	return freq;
}

function midiToFreq(note) {
	//21-108
	//console.log('note '+note);
	return A0_FREQ * Math.pow(2, (note-21)/12);
}

function compile() {
	var inputNotes = document.getElementById("inputNotes").value.trim().toLowerCase().replace(/\n/g, '').split(",");

	var notes = inputNotes.map(function(value) {return noteToFreq(value);});

	return notes;
}

function compileMidi(events, timeStep) {
	let notes = [];
	//let BPM = 120;

	//let timeStep = 60 / (BPM * ppqn);
	//let timeStep = 1 / (2 * ppqn)
	//var time = PLAYBACK_DELAY/timeStep;
	let time = PLAYBACK_DELAY;

	let lastTime = 0;

/*
	var i, j = 0;
	while (i < timing.length) {
		if (timing[i]["time"] < events[j]["time"]) {
			events.splice(j, 0, timing[i++]);
		}

		j++
	}
*/
	let openNotes = {};


	for (let i = 0; i < events.length; i++) {
		let event = events[i];
		time += timeStep * (event["time"] - lastTime);
		lastTime = event["time"];

		if (event["status"] == 0xFF51) {
			// Change tempo
			timeStep = event["step"];

			//console.log("new timeStep: " + timeStep);
		} else if (event["status"] >> 4 == 0x9 && event["velocity"] != 0) {
			// Open note


			//console.log("open");
			//var key = {"start" : timeStep*time, "freq" : midiToFreq(event["note"])};
			//var note = {"start" : timeStep*time, "key" : event["key"], "velocity" : event["velocity"]};
			let note = {
				"start" : time,
				"key" : event["key"],
				"channel" : event["channel"],
				"velocity" : event["velocity"]};

			let noteId = event["channel"] + " " + event["key"];
			let noteIndex = notes.push(note) - 1;
			//console.log("NoteId: " + noteId);
			

			if (noteId in openNotes && openNotes[noteId].length > 0) {
				//console.log("Warning: Note already open (" + noteId + ") " + time);
			} else {
				openNotes[noteId] = [];
			}
			openNotes[noteId].push(noteIndex);
		} else if ((event["status"] >> 4 == 0x8) || (event["status"] >> 4 == 0x9 && event["velocity"] == 0)) {
			// Close note

			let noteId = event["channel"] + " " + event["key"];
			if (noteId in openNotes && openNotes[noteId].length > 0) {
				//console.log("pre: " + openNotes[noteId].length);
				let noteIndex = openNotes[noteId].shift();
				//console.log("post: " + openNotes[noteId].length);
				//console.log("test: " + openNotes[noteId]);
				notes[noteIndex]["end"] = time;

				//delete openNotes[noteId];
			} else {
				console.log("Warning: Note already closed (" + noteId + ")");
			}
		} else {
			//console.log("Warning: Unsupported event (" + event["status"] + ")");
		}
/*
			var testOpen = true;

			var end = time;
			for (var j = i+1; j < events.length; j++) {
				var nextEvent = events[j];
				end += nextEvent["time"];
				//console.log("c "+nextEvent["velocity"]);
				if (((nextEvent["status"] >> 4 == 0x8) || (nextEvent["status"] >> 4 == 0x9 && nextEvent["velocity"] == 0)) &&
					nextEvent["key"] == event["key"] && (nextEvent["status"] & 0xF) == (event["status"] & 0xF)) {
					//console.log("close");
					//note["end"] = timeStep*end;
					note["end"] = end;
					testOpen = false;
					break;
				}
			}

			if (testOpen) {
				console.log("LEFT OPEN " + note["start"] + " " + event["key"]);
			} else {
				notes.push(note);
			}

			
		}
		*/
	}

	for (let note in openNotes) {
		if (openNotes[note].length == 0) continue;
		console.log("Warning: Note left open (" + note + ")");
	}

	return notes;
}

function playMidi(notes) {
	
	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	audioCtx.suspend();
	//console.log(events.length);

	console.log(audioCtx.currentTime + " sec FIRST");

	let waves = [];
	//let keyWaves = {};

	var wc = 0;

	//var delay = audioCtx.createDelay(SIZE_SECONDS);
	//delay.delayTime.value = SIZE_SECONDS;
	//delay.connect(audioCtx.destination)

	function newWave() {
		
		var osc = audioCtx.createOscillator();
		var vol = audioCtx.createGain();

		osc.type = "triangle";
		vol.gain.value = 0;

		osc.connect(vol);
		//vol.connect(delay);
		//vol.connect(audioCtx.destination);
		osc.start();

		var wave = {"osc" : osc, "vol" : vol};

		return wave;
	}

	// TODO: Percussion as sine?

	function getWave() {
		//console.log('before'+waves.length);
		var wave = waves.shift();
		//console.log('after '+waves.length);
		if (wave == undefined) {
			console.log("New wave " + (++wc));
			//waves.push(newWave());
			wave = newWave();

			
			
			//wave.onended = function() {
				//waves.push(this);
			//}
			
			
			//wave.start();
		} else {
			//console.log("Old wave");
		}



		wave["vol"].connect(audioCtx.destination);
		//wave["osc"].start();

		return wave;
	}

	console.log(notes[0]["start"] + " asasfa");

	//var i = 0;

	//TODO: HANDLE MULTIPLE IN ONE PASS

	function playMidi_r(i) {
		//console.log(++i + "events processed");
		let curTime = audioCtx.currentTime;// - SIZE_SECONDS;


		//console.log(curTime + " sec");

		//while (keys[0] != undefined && (keys[0]["start"] <= (audioCtx.currentTime + 0.1))) {
		//do {
			//console.log("note");
		//var note = notes.shift();
		let note = notes[i++];
		//

		if ((note["start"] - curTime) >= 0.1) {
			console.log("Warning: Excessive note latency - " + (note["start"] - curTime));
		}

		let wave = getWave();
		wave["osc"].frequency.value = midiToFreq(note["key"]);

		let bassBoost = (1+(110 - note["key"])/110) / 2;
		//bassBoost = 1;

		wave["vol"].gain.setTargetAtTime(bassBoost * VOLUME * note["velocity"] / 127, 0, 0.005);
		//wave["vol"].gain.value = VOL
		//wave["vol"].gain.value = VOLUME;
		//if (note["end"] - curTime > 0.5) {
		wave["vol"].gain.setTargetAtTime(VOLUME/10, curTime + 0.25, 0.6);
		//}
		
		//console.log(note["key"]);
		wave["vol"].gain.setTargetAtTime(0, note["end"], 0.005);
		wave["vol"].gain.cancelScheduledValues(note["end"] + 0.15);
		//wave["vol"].gain.setValueAtTime(0, note["end"] + 0.1);

		setTimeout(function() {
				//wave["vol"].gain.cancelScheduledValues(0);
				//wave["vol"].gain.value = 0;
				wave["vol"].disconnect(audioCtx.destination);
				waves.push(wave);
		}, (note["end"] - curTime)*1000 + 200);

		//console.log(keys[0]["start"]);
		//} while(keys[0]["start"] == key["start"]);

		//console.log("c: "+keys.length);
		if (i < notes.length) {
			setTimeout(playMidi_r, (notes[i]["start"] - curTime)*1000, i);
		}

	}

	for (var i = 0; i < 20; i++) {
		waves.push(newWave());
	}

	audioCtx.resume();
	if (notes.length > 0) {
		setTimeout(playMidi_r, (notes[0]["start"] - audioCtx.currentTime)*1000, 0);
/*
		setTimeout(function() {
			audioCtx.resume();
			setTimeout(playMidi_r, (keys[0]["start"])*1000);
		}, SIZE_SECONDS * 1000);*/
	}

	drawNotes(audioCtx, notes);
}


function playback() {
	var notes = compile()


	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	// we create the gain module, named as volume, and connect it to our
	var volume = audioCtx.createGain();
	volume.connect(audioCtx.destination);
	//these sines are the same, exept for the last connect statement.
	//Now they are connected to the volume gain module and not to the au
	var wave = audioCtx.createOscillator();
	wave.type = "triangle";
	wave.frequency.value = 440;
	//wave.detune.value = -100;
	//sinea.type = "sine";
	volume.gain.value = 0;
	wave.start();
	//wave.stop(audioCtx.currentTime + 3);
	wave.connect(volume);

	playRecursive(audioCtx, wave, volume, notes, 0);

}

function playRecursive(context, wave, volume, notes, i) {
	if (i >= notes.length) {
		wave.stop(context.currentTime + 0.1);
		return;
	}

	

	if (notes[i] != 0) {
		

		wave.frequency.value = notes[i];
		//volume.gain.value = 0.2;
		volume.gain.setTargetAtTime(VOLUME, context.currentTime, 0.01);

		volume.gain.setTargetAtTime(0, context.currentTime + 0.9*METER, 0.01);
	}

	setTimeout(playRecursive, 1000*METER, context, wave, volume, notes, i+1);
}



</script>

</body>
</html>