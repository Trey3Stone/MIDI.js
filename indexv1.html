<html>
<body bgcolor="#222222" scroll="no" style="margin: 0; overflow: hidden;">
<textarea id="inputNotes">
e4,e4,_,e4,_,c4,e4,_,
g4,_,_,_,g3,_,_,_,
c4,_,_,g3,_,_,e3,_,
_,a3,_,b3,_,a#3,a3,_,
g3,e4,g4,a4,_,f4,g4,
_,e4,_,c4,d4,b3,_,_
</textarea>

<button id="playButton" onClick="playback()">
	Play
</button>



<div id='d1' style="position: absolute; bottom: 0px">
	<canvas id="canvas" style="bottom:0px">
	  <p>Canvas not supported!</p>
	</canvas>
	<input type="file" id="fileUpload" accept=".mid" onChange="checkFile()">
</div>

<script type="text/javascript">
	// DoReMi: c3,d3,e3,f3,g3,a3,b3,c4
//

	const A0_FREQ = 27.5;
	const KEYS = 8;

	const VOLUME = 0.05;

	const TEMPO = 45; // Supports 8th notes
	const METER = 60 / TEMPO / 8;

	const SIZE_SECONDS = 4;
	const PLAYBACK_DELAY = 2;

	

	const NOTE_STEP = Math.pow(2, 1/12);

	const NOTE_TABLE = {
		'c' :  0,
		'c#':  1,
		'd' :  2,
		'd#':  3,
		'e' :  4,
		'f' :  5,
		'f#':  6,
		'g' :  7,
		'g#':  8,
		'a' :  9,
		'a#': 10,
		'b' : 11
	}

	const NOTES = [
		'c' ,
		'c#',
		'd' ,
		'd#',
		'e' ,
		'f' ,
		'f#',
		'g' ,
		'g#',
		'a' ,
		'a#',
		'b'
	]

	var BPM = 120;

	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;//Width / 6;

	drawCanvas();


function drawCanvas() {
	
	ctx.save();

	let width = canvas.width;
	let height = width / 6;

	ctx.translate(0, canvas.height - height)

	ctx.beginPath();
	ctx.rect(0, 0, width, height);
	ctx.clip();

	ctx.strokeStyle = "rgb(34, 34, 34)";

	//ctx.fillStyle = "rgb(40, 40, 40)";
	//ctx.fillRect(0, 0, canvas.width, canvas.height);

	//ctx.strokeStyle = "rgb(40, 40, 40)";

	const keyWidth = canvas.width/52;
	const keyHeight = canvas.width/6;

	var xFill = 0;
	ctx.fillStyle = "rgb(255, 255, 255)";
	
	ctx.lineWidth = 2;

	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] == '#') {
			continue;
		}


		
		//ctx.fillRect(xFill+1, canvas.height - keyHeight, keyWidth-2, keyHeight-2);
		fillRoundedRect(xFill+1, 0, keyWidth-2, keyHeight-2, 2);
		xFill = xFill + keyWidth;
	}

	xFill = 0;
	ctx.fillStyle = "rgb(250, 150, 100)";

	for (var i = 0; i < 88; i++) {
		if (NOTES[(9+i)%12][1] != '#') {
			xFill = xFill + keyWidth;
			continue;
		}


		
		//ctx.fillRect(xFill - keyWidth/4, canvas.height - keyHeight, keyWidth/2, keyHeight*0.6-2);
		fillRoundedRect(xFill - keyWidth/4, 0, keyWidth/2, keyHeight*0.6-2, 2);
		
	}

	ctx.fillStyle = "rgb(255, 255, 255)";
	ctx.lineWidth = 16;
	fillRoundedRect(0, 0, width, 4, 2);

	ctx.restore();

}

function fillRoundedRect(x, y, w, h, r) {
	ctx.save();

	ctx.translate(x, y);

	ctx.beginPath();
	ctx.arc(r, r, r, Math.PI, 3*Math.PI/2);
	ctx.arc(w - r, r, r, 3*Math.PI/2, 0);
	ctx.arc(w - r, h - r, r, 0, Math.PI/2);
	ctx.arc(r, h - r, r, Math.PI/2, Math.PI);

	ctx.closePath();

	//ctx.strokeStyle = "rgb(40, 40, 40)";
	
	ctx.stroke();

	ctx.fill();

	ctx.restore();
}

function drawNotes(audioCtx, notes) {
	/*
	const times = [];
	let fps;

	function refreshLoop() {
	  window.requestAnimationFrame(() => {
	    const now = performance.now();
	    while (times.length > 0 && times[0] <= now - 1000) {
	      times.shift();
	    }
	    times.push(now);
	    fps = times.length;
	    console.log(fps);
	    refreshLoop();
	  });
	}

	refreshLoop();
	*/

	var width = canvas.width;
	var height = canvas.height - canvas.width/6;

	function drawNotes_r(audioCtx, notes, curNotes, i) {
		//console.log("1: " + curNotes.length);
		var curTime = audioCtx.currentTime;

		

		ctx.save();

		ctx.lineWidth = 4;

		ctx.beginPath();
		ctx.rect(0, 0, width, height);
		ctx.clip();

		ctx.clearRect(0, 0, width, height);

		ctx.fillStyle = "rgb(200, 40, 40)";

		//for (var note of notes) {
		while (i < notes.length) {
			var note = notes[i];
			if (note["start"] <= (curTime + SIZE_SECONDS)) {
				//console.log("added");
				curNotes.push(note);
				i++;
			} else {
				break;
			}
		}
		//console.log("2: " + curNotes.length);

		curNotes = curNotes.filter(function(note) {
			return note["end"] > curTime;
		});

		//console.log("3: " + curNotes.length);

		ctx.strokeStyle = "rgb(40, 40, 40)";

		for (var note of curNotes) {


			var noteHeight = (note["end"] - note["start"]) / SIZE_SECONDS * height;

			var noteX = width * (note["key"] - 21) / 88;
			//console.log(noteX);
			var noteY = height * (1 - (note["end"] - curTime) / SIZE_SECONDS);

			if (note["start"] > curTime) {
				ctx.fillStyle = "rgb(200, 100, 100)";
			} else {
				ctx.fillStyle = "rgb(150, 75, 75)";
			}


			//ctx.fillRect(noteX, noteY, 20, noteHeight);
			fillRoundedRect(noteX, noteY, 20, noteHeight, 5);
		}



		ctx.restore();

		if (curNotes.length > 0 || i < notes.length) {
			window.requestAnimationFrame(function(timestamp) {
				drawNotes_r(audioCtx, notes, curNotes, i);
			});
		} else {
			ctx.clearRect(0, 0, width, height);
		}
	}

	drawNotes_r(audioCtx, notes, [], 0);	
}


function checkFile() {
	//document.write(note+"<br>");
	
	var inputFile = document.getElementById("fileUpload").files[0];

	if (inputFile == undefined) {
		alert("No valid file selected");
		return;
	}

	var reader = new FileReader();
	reader.onload = function(e) {
		decodeFile(e.target.result);
	}

	reader.readAsArrayBuffer(inputFile);

}

function decodeFile(res) {

	var data = new DataView(res);
	
	var chunkId = String.fromCharCode.apply(String, [data.getUint8(0), data.getUint8(1), data.getUint8(2), data.getUint8(3)]);
	var chunkLen = data.getUint32(4);
 	
 	var format = data.getUint16(8);
 	var ntracks = data.getUint16(10);
 	var tickdiv = data.getUint16(12);

	console.log("ntracks: " +ntracks);

 	if (tickdiv & 0x8000 != 0) {
 		alert("Timecodes not implemented yet");
 		return;
 	}

 	if (format != 1) {
 		alert("Format not implemented yet");
 		return;
 	}

 	var ppqn = tickdiv & 0x7fff;

	console.log("speeedd"+tickdiv);

	chunkLen = data.getUint32(18);

	console.log("Tempo Chunk size: "+chunkLen);

	//var start = 22+chunkLen;

	var start = 14;

//Marker, Cue Point, Tempo, SMPTE Offset, Time Signature, and Key Signature

/*
Metas: 84 0 81 9 47 82 54
       54 0 51 9 2f 52 36




*/


	/*
	chunkId = String.fromCharCode.apply(String,
		[data.getUint8(start), data.getUint8(start+1), data.getUint8(start+2), data.getUint8(start+3)]);

	chunkLen = data.getUint32(start+4);
*/
	//console.log(chunkId +": " +chunkLen);

	var i = start;

	function readChunk() {
		console.log("reading");

		chunkId = String.fromCharCode.apply(String,
			[data.getUint8(i), data.getUint8(i+1), data.getUint8(i+2), data.getUint8(i+3)]);

		if (chunkId != "MTrk") {
			alert(chunkId);
			return;
		}

		chunkLen = data.getUint32(i+4);

		start = i + 8;
		i = start;

		var events = [];
		var lastStatus = 0;

		var dt = 0;

		while(i < start + chunkLen - 1) {
			
			var next = data.getUint8(i++);

			//console.log((i-1)+" " +(next));

			dt = (dt << 7) | (next & 0x7f);
			if ((next & 0x80) == 0) {
				//console.log("go0");
				event = {"time" : dt};
				dt = 0;

				event["status"] = data.getUint8(i++);
				if (event["status"] < 128) {
					event["status"] = lastStatus;
					i--;
				} else {
					lastStatus = event["status"];
				}

				//console.log("EVENT: " + event["status"] + " " + (i - 1 - start) + " " + event["time"]);

				//var testPutInEventsList = false;

				switch(event["status"] >> 4) {
					case 0x8:
						event["key"] = data.getUint8(i++);
						//console.log(data.getUint8(i));
						event["velocity"] = data.getUint8(i++);
						//testPutInEventsList = true;
						break;
					case 0x9:
						event["key"] = data.getUint8(i++);
						event["velocity"] = data.getUint8(i++);
						//testPutInEventsList = true;
						break;
					case 0xA:
						i+=2;
						break;
					case 0xB:
						i+=2;
						break;
					case 0xC:
						i+=1;
						break;
					case 0xD:
						i+=1;
						break;
					case 0xE:
						i+=2;
						break;
					case 0xF:
						if (event["status"] == 0xFF) {
							let opt = data.getUint8(i++);
							event["status"] = 0xFF00 | opt;
							//console.log("New meta event: " + opt + " " + data.getUint8(i) + " " + (i - 1 - start));
							switch(opt) {
								case 0x51:
									i++;
									let tempo = data.getUint8(i++);
									tempo = (tempo << 8) | data.getUint8(i++);
									tempo = (tempo << 8) | data.getUint8(i++);
									//console.log("tempo: " + tempo);
									console.log("bpm?: " + (60000000/(tempo)));
									BPM = 60000000/tempo;

									let timeStep = tempo / (1000000 * ppqn);

									event["step"] = timeStep;


									console.log("bpm: " + BPM);
									break;
								default:
									var length = data.getUint8(i++);
									i+=length;
							}


							
						} else {
							console.log(event["status"] + " " + data.getUint8(i));
						}
							/*if ((opt >> 4) == 0) {
								i+=data.getUint8(i);
							} else {
								if (opt == 0x2F) {
									//return events;
								}
							}
						} else {
							i+=data.getUint8(i);
						}*/
						//console.log(event["status"] + " " + data.getUint8(i));
						break;
					default:
						alert("Something broke.");
						console.log("ERROR");
						return;
						//while(data.getUint8(i++) >> 7 == 0)
				}

				//console.log("go1");
				//if (testPutInEventsList) {
				events.push(event);
				//}
				
				
			}
			
		}
		i = start + chunkLen;
		return events;
	}

	function mergeStreams(a, b) {
		var i = 0;
		while (b.length > 0) {
			if (a[i] == undefined || a[i]["start"] > b[0]["start"]) {
				a.splice(i, 0, b.shift());
			}

			i++
		}

		return a;
	}


	timing = compileMidi(readChunk(), ppqn);

	stream = [];

	//var testcount = stream.length;
	console.log("length: " + stream.length);
	for (var n = 1; n < ntracks; n++) {
		//console.log("track");
		var test = compileMidi(timing, readChunk());
		//console.log("length: " + test.length);
		//testcount += test.length;
		mergeStreams(stream, test);
	}

	//console.log(testcount + " " + stream.length);
	//var keys = compileMidi(streams[0], ppqn);
	playMidi(stream);
}

function noteToFreq(note) {
	
	if (note[0] == '_') {
		return 0;
	}

	var key = note.slice(0, -1);
	var oct = note.slice(-1);

	//document.write(note+' '+key+' '+oct+'<br>');

	// TODO: assert key and oct are valid

	var freq = A0_FREQ * Math.pow(2, parseInt(oct) + (NOTE_TABLE[key] - 9)/12);
	return freq;
}

function midiToFreq(note) {
	//21-108
	//console.log('note '+note);
	return A0_FREQ * Math.pow(2, (note-21)/12);
}

function compile() {
	var inputNotes = document.getElementById("inputNotes").value.trim().toLowerCase().replace(/\n/g, '').split(",");

	var notes = inputNotes.map(function(value) {return noteToFreq(value);});

	return notes;
}

function compileMidi(events, ppqn) {
	var notes = [];

	var timeStep = 60 / (BPM * ppqn);
	var time = PLAYBACK_DELAY/timeStep;

/*
	var i, j = 0;
	while (i < timing.length) {
		if (timing[i]["time"] < events[j]["time"]) {
			events.splice(j, 0, timing[i++]);
		}

		j++
	}
*/

	for (var i = 0; i < events.length; i++) {
		var event = events[i];
		time += event["time"];
		if (event["status"] >> 4 == 0x9 && event["velocity"] != 0) {
			//console.log("open");
			//var key = {"start" : timeStep*time, "freq" : midiToFreq(event["note"])};
			//var note = {"start" : timeStep*time, "key" : event["key"], "velocity" : event["velocity"]};
			var note = {"start" : time, "key" : event["key"], "velocity" : event["velocity"]};

			var testOpen = true;

			var end = time;
			for (var j = i+1; j < events.length; j++) {
				var nextEvent = events[j];
				end += nextEvent["time"];
				//console.log("c "+nextEvent["velocity"]);
				if (((nextEvent["status"] >> 4 == 0x8) || (nextEvent["status"] >> 4 == 0x9 && nextEvent["velocity"] == 0)) &&
					nextEvent["key"] == event["key"] && (nextEvent["status"] & 0xF) == (event["status"] & 0xF)) {
					//console.log("close");
					//note["end"] = timeStep*end;
					note["end"] = end;
					testOpen = false;
					break;
				}
			}

			if (testOpen) {
				console.log("LEFT OPEN " + note["start"] + " " + event["key"]);
			} else {
				notes.push(note);
			}

			
		}
	}

	return notes;
}

function playMidi(notes) {
	
	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	audioCtx.suspend();
	//console.log(events.length);

	console.log(audioCtx.currentTime + " sec FIRST");

	var waves = [];

	var wc = 0;

	//var delay = audioCtx.createDelay(SIZE_SECONDS);
	//delay.delayTime.value = SIZE_SECONDS;
	//delay.connect(audioCtx.destination)

	function newWave() {
		
		var osc = audioCtx.createOscillator();
		var vol = audioCtx.createGain();

		osc.type = "triangle";
		vol.gain.value = 0;

		osc.connect(vol);
		//vol.connect(delay);
		vol.connect(audioCtx.destination);
		osc.start();

		var wave = {"osc" : osc, "vol" : vol};

		return wave;
	}

	// TODO: Percussion as sine?

	function getWave() {
		//console.log('before'+waves.length);
		var wave = waves.pop();
		//console.log('after '+waves.length);
		if (wave == undefined) {
			console.log("New wave " + (++wc));
			//waves.push(newWave());
			wave = newWave();

			
			
			//wave.onended = function() {
				//waves.push(this);
			//}
			
			
			//wave.start();
		} else {
			//console.log("Old wave");
		}

		//wave["vol"].connect(audioCtx.destination);
		//wave["osc"].start();

		return wave;
	}

	console.log(notes[0]["start"] + " asasfa");

	//var i = 0;

	//TODO: HANDLE MULTIPLE IN ONE PASS

	function playMidi_r(i) {
		//console.log(++i + "events processed");
		let curTime = audioCtx.currentTime;// - SIZE_SECONDS;


		//console.log(curTime + " sec");

		//while (keys[0] != undefined && (keys[0]["start"] <= (audioCtx.currentTime + 0.1))) {
		//do {
			//console.log("note");
		//var note = notes.shift();
		let note = notes[i++];
		//

		if ((note["start"] - curTime) >= 0.1) {
			console.log("Warning: Excessive note latency - " + (note["start"] - curTime));
		}

		let wave = getWave();
		wave["osc"].frequency.value = midiToFreq(note["key"]);
		wave["vol"].gain.setTargetAtTime(VOLUME * note["velocity"] / 127, note["start"], 0.005);
		//wave["vol"].gain.value = VOL
		//wave["vol"].gain.value = VOLUME;
		//wave["vol"].gain.setTargetAtTime(0, curTime + 0.5, 0.5);
		wave["vol"].gain.setTargetAtTime(0, note["end"], 0.005);

		setTimeout(function() {
				waves.push(wave);
		}, (note["end"] - curTime)*1000 + 100);

		//console.log(keys[0]["start"]);
		//} while(keys[0]["start"] == key["start"]);

		//console.log("c: "+keys.length);
		if (i < notes.length) {
			setTimeout(playMidi_r, (notes[i]["start"] - curTime)*1000, i);
		}

	}

	for (var i = 0; i < 20; i++) {
		waves.push(newWave());
	}

	audioCtx.resume();
	if (notes.length > 0) {
		setTimeout(playMidi_r, (notes[0]["start"] - audioCtx.currentTime)*1000, 0);
/*
		setTimeout(function() {
			audioCtx.resume();
			setTimeout(playMidi_r, (keys[0]["start"])*1000);
		}, SIZE_SECONDS * 1000);*/
	}

	drawNotes(audioCtx, notes);
}


function playback() {
	var notes = compile()


	var audioCtx = new (window.AudioContext || window.webkitAudioContext);
	// we create the gain module, named as volume, and connect it to our
	var volume = audioCtx.createGain();
	volume.connect(audioCtx.destination);
	//these sines are the same, exept for the last connect statement.
	//Now they are connected to the volume gain module and not to the au
	var wave = audioCtx.createOscillator();
	wave.type = "triangle";
	wave.frequency.value = 440;
	//wave.detune.value = -100;
	//sinea.type = "sine";
	volume.gain.value = 0;
	wave.start();
	//wave.stop(audioCtx.currentTime + 3);
	wave.connect(volume);

	playRecursive(audioCtx, wave, volume, notes, 0);

}

function playRecursive(context, wave, volume, notes, i) {
	if (i >= notes.length) {
		wave.stop(context.currentTime + 0.1);
		return;
	}

	

	if (notes[i] != 0) {
		

		wave.frequency.value = notes[i];
		//volume.gain.value = 0.2;
		volume.gain.setTargetAtTime(VOLUME, context.currentTime, 0.01);

		volume.gain.setTargetAtTime(0, context.currentTime + 0.9*METER, 0.01);
	}

	setTimeout(playRecursive, 1000*METER, context, wave, volume, notes, i+1);
}



</script>

</body>
</html>